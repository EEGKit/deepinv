# %%
import torch
from typing import Tuple

# TODO: motion blurs, diffraction


class RandomPSF(object):
    r"""
    Generic class for random PSF generation.

    :param int, tuple[int] kernel_size: the size of the generated kernel (PSF) in pixels. If kernel_size is an integer, a square PSF is generated, if kernel_size is a tuple of 2 integers, a PSF of size (kernel_size[0], kernel_size[1]) is generated.
    """

    def __init__(self, kernel_size: Tuple[int, ...] = 51, dtype=torch.float32, device='cpu') -> None:
        if isinstance(kernel_size, int):
            kernel_size = (kernel_size, kernel_size)

        self.kernel_size = kernel_size
        # The default Dirac mass (identity)
        self.dirac_mass = torch.zeros(
            (1, 1, kernel_size[0], kernel_size[1]), dtype = dtype, device = device)
        self.dirac_mass[..., kernel_size[0] // 2, kernel_size[1] // 2] = 1.

    def __call__(self):
        pass

# Generate random PSFs as described here: https://arxiv.org/pdf/1406.7444.pdf

class GaussianTrajectory(RandomPSF):
    r"""
    Random motion blurs. A blur trajectory is generated by sampling both its x- and y-coordinates independently
    from a Gaussian Process with a MatÃ©rn 3/2 covariance function.

    .. math::

        f_x(t), f_y(s) \sim \mathcal{GP}(0, k(t, s))



    where :math:`k(t,s)` is defined as 

    .. math::

        k(t, s) = \sigma^2 \left( 1 + \frac{\sqrt{5} |t -s|}{l} + \frac{5 (t-s)^2}{3 l^2} \right) \exp \left(-\frac{\sqrt{5} |t-s|}{l}\right)


    :param float l: the length scale of the trajectory, defaults to 0.3
    :param float sigma: the standard deviation of the Gaussian Process, defaults to 0.25
    :param int n_steps: the number of points in the trajectory, defaults to 1000
    
    |sep|

    :Examples:

    >>> PSFGenerator = GaussianTrajectory(51)
    >>> kernel = PSFGenerator(4, 0.25, 0.3)
    >>> print(kernel.shape)
    >>> dinv.utils.plot(kernel[0,0])
    >>> dinv.utils.plot(PSFGenerator.dirac_mass[0, 0])
    """

    def __init__(self, kernel_size: Tuple[int, ...] = 51,
                 l: float = 0.3,
                 sigma: float = 0.25,
                 n_steps: int = 1000,
                 device = 'cpu',
                 dtype = torch.float32) -> None:
        super().__init__(kernel_size, device = device, dtype = dtype)
        self.l = l
        self.sigma = sigma
        self.n_steps = n_steps
        self.device = device
        self.dtype = dtype

    # @torch.compile
    def matern_kernel(self, diff, sigma=None, l=None):
        if sigma is None:
            sigma = self.sigma
        if l is None:
            l = self.l

        fraction = 5**0.5 * diff.abs() / l
        return sigma ** 2 * (1 + fraction + fraction ** 2 / 3) * torch.exp(-fraction)

    # @torch.compile
    def f_matern(self, batch_size, sigma=None, l=None):
        vec = torch.randn(batch_size, self.n_steps, dtype = self.dtype, device = self.device)
        time = torch.linspace(-torch.pi, torch.pi, self.n_steps, device = self.device, dtype = self.dtype)[None]

        kernel = self.matern_kernel(time, sigma, l)
        kernel_fft = torch.fft.rfft(kernel)
        vec_fft = torch.fft.rfft(vec)
        return torch.fft.irfft(vec_fft * torch.sqrt(kernel_fft)).real[:, torch.arange(self.n_steps // (2 * torch.pi)).type(torch.int)]

    def __call__(self, batch_size, sigma=None, l=None):
        r"""
        Generate a random PSF with parameters :math: '\sigma' and :math: `l`

        :param int batch_size: the batch size
        :param float sigma: the standard deviation of the Gaussian Process
        :param float l: the length scale of the trajectory

        :return: the generated PSF of shape `(batch_size, 1, kernel_size, kernel_size)`
        :rtype: torch.Tensor
        """

        f_x = self.f_matern(batch_size, sigma, l)[..., None]
        f_y = self.f_matern(batch_size, sigma, l)[..., None]
        trajectories = torch.cat((f_x - torch.mean(f_x, dim=1, keepdim=True),
                                  f_y - torch.mean(f_y, dim=1, keepdim=True)), dim=-1)
        kernels = [torch.histogramdd(
            trajectory, bins=list(self.kernel_size), range=[-1, 1, -1, 1])[0][None, None] for trajectory in trajectories]
        kernel = torch.cat(kernels, dim=0)
        kernel = kernel / torch.sum(kernel, dim=(-2, -1), keepdim=True)
        return kernel


if __name__ == "__main__":
    import matplotlib.pyplot as plt
    PSFGenerator = GaussianTrajectory(51)

    kernel = PSFGenerator(4, 0.25, 0.3)
    print(kernel.shape)
    plt.imshow(kernel[0, 0], cmap='gray')
    plt.show()
    plt.imshow(PSFGenerator.dirac_mass[0, 0], cmap='gray')
    plt.show()
