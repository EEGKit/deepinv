import torch
import torch.nn as nn
from typing import List, Union
import warnings


class PhysicsGenerator(nn.Module):
    r"""
    Base class for parameter generation of physics parameters.

    Physics generators are used to generate the parameters :math:`\theta` of (parameter-dependent) forward operators.

    Generators can be summed to create larger generators via :meth:`deepinv.physics.generator.PhysicsGenerator.__add__`,
    or mixed to create a generator that randomly selects them via :meth:`deepinv.physics.generator.GeneratorMixture`.

    :param Callable step: a function that generates the parameters of the physics, e.g.,
        the filter of the :meth:`deepinv.physics.Blur`. This function should return the parameters in a dictionary with
        the corresponding key and value pairs.
    :param torch.Generator (Optional) rng: a pseudorandom random number generator for the parameter generation. 
        If ``None``, the default Generator of PyTorch will be used. This `rng` will be passed to the `step` function.
    :param str device: cpu or cuda
    :param torch.dtype dtype: the data type of the generated parameters

    |sep|

    :Examples:

        Generating blur and noise levels:

        >>> import torch
        >>> from deepinv.physics.generator import MotionBlurGenerator, SigmaGenerator
        >>> _ = torch.manual_seed(0)
        >>> # combine a PhysicsGenerator for blur and noise level parameters
        >>> generator = MotionBlurGenerator(psf_size = (3, 3), num_channels = 1) + SigmaGenerator()
        >>> params_dict = generator.step(batch_size=1) # dict_keys(['filter', 'sigma'])
        >>> print(params_dict['filter'])
        tensor([[[[0.0000, 0.1006, 0.0000],
                  [0.0000, 0.8994, 0.0000],
                  [0.0000, 0.0000, 0.0000]]]])
        >>> print(params_dict['sigma'])
        tensor([0.1577])
    """

    def __init__(
        self, step=lambda **kwargs: {}, rng: torch.Generator = None, device="cpu", dtype=torch.float32, **kwargs
    ) -> None:
        super().__init__()

        self.step_func = step
        self.kwargs = kwargs
        self.factory_kwargs = {"device": device, "dtype": dtype}

        self.initial_random_state = rng.get_state()
        # Make sure that the random generator is on the same device as the physic generator
        if rng.device != torch.device(device):
            self.rng = torch.Generator(
                device).set_state(self.initial_random_state)
        else:
            self.rng = rng

        # Set attributes
        for k, v in kwargs.items():
            setattr(self, k, v)

    def step(self, batch_size: int = 1, seed: int = None, **kwargs):
        r"""
        Generates a batch of parameters for the forward operator.

        :param int batch_size: the number of samples to generate.
        :returns: A dictionary with the new parameters, that is ``{param_name: param_value}``.
        """
        self.rng_manual_seed(seed)
        if kwargs is not None:
            self.kwargs = kwargs

        return self.step_func(batch_size, self.rng, seed, **kwargs)

    def rng_manual_seed(self, seed: int = None):
        if seed is not None:
            if self.rng is not None:
                self.rng = self.rng.manual_seed(seed)
            else:
                torch.manual_seed(seed)
                raise warnings.warn(
                    "Cannot set seed when rng is None! The `torch.manual_seed` is triggered.")

    def __add__(self, other):
        r"""
        Creates a new generator from the sum of two generators.

        :param Generator other: the other generator to be added.
        :returns: A new generator that generates a larger dictionary with parameters of the two generators.
        """

        def step(**kwargs):
            x = self.step(**kwargs)
            y = other.step(**kwargs)
            d = {k: x.get(k, 0) + y.get(k, 0) for k in set(x) | set(y)}
            return d

        return PhysicsGenerator(step=step)


class GeneratorMixture(PhysicsGenerator):
    r"""
    Base class for mixing multiple :class:`PhysicsGenerator`.

    The mixture randomly selects a subset of batch elements
    to be generated by each generator according to the probabilities given in the constructor.

    :param list[PhysicsGenerator] generators: the generators instantiated from :meth:`deepinv.physics.generator.PhysicsGenerator`.
    :param list[float] probs: the probability of each generator to be used at each step

    |sep|

    :Examples:

        Mixing two types of blur

        >>> from deepinv.physics.generator import MotionBlurGenerator, DiffractionBlurGenerator
        >>> from deepinv.physics.generator import GeneratorMixture
        >>> _ = torch.manual_seed(0)
        >>> g1 = MotionBlurGenerator(psf_size = (3, 3), num_channels = 1)
        >>> g2 = DiffractionBlurGenerator(psf_size = (3, 3), num_channels = 1)
        >>> generator = GeneratorMixture([g1, g2], [0.5, 0.5])
        >>> params_dict = generator.step(batch_size=1)
        >>> print(params_dict.keys())
        dict_keys(['filter'])

    """

    def __init__(self, generators: List[PhysicsGenerator], probs: List[float]) -> None:
        super().__init__()
        probs = torch.tensor(probs)
        assert torch.sum(probs) == 1, "The sum of the probabilities must be 1."
        self.generators = generators
        self.probs = probs
        self.cum_probs = torch.cumsum(probs, dim=0)

    def step(self, batch_size: int = 1, seed: int = None, **kwargs):
        r"""
        Returns a new set of physics' parameters,
        according to the probabilities given in the constructor.

        :param int batch_size: the number of samples to generate.
        :returns: A dictionary with the new parameters, ie ``{param_name: param_value}``.
        """
        # self.factory_kwargs = {"device": self.params.device, "dtype": self.params.dtype}
        p = torch.rand(1).item()  # np.random.uniform()
        idx = torch.searchsorted(self.cum_probs, p)
        return self.generators[idx].step(batch_size, seed, **kwargs)
